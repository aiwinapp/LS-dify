# auth-readme.md

Авторизация пользователя в проекте происходит следующим образом:
1. Пользователь попадает на страницу входа (app/(shareLayout)/login/page.tsx).
2. На странице входа пользователь вводит email и пароль. Также есть возможность авторизоваться через GitHub или Google.
3. При отправке формы вызывается функция signIn из service/auth.ts, которая отправляет запрос на сервер для авторизации пользователя.
4. Сервер проверяет учетные данные пользователя и, если они верны, возвращает JWT токен.
5. Полученный JWT токен сохраняется в localStorage и используется для последующих запросов к API, требующих авторизации.
6. После успешной авторизации пользователь перенаправляется на страницу app/(commonLayout)/studio/page.tsx.
7. На всех страницах, требующих авторизации (расположенных в app/(commonLayout)), используется компонент AuthGuard из app/components/auth/auth-guard.tsx.
AuthGuard проверяет наличие JWT токена в localStorage и, если его нет, перенаправляет пользователя на страницу входа.
9. Если JWT токен присутствует, AuthGuard пропускает пользователя на запрошенную страницу.
10. Информация о текущем пользователе (имя, email и т.д.) получается из API с помощью функции fetchUserInfo из service/user.ts и сохраняется в контексте UserContext.
11. Компоненты, которым нужна информация о текущем пользователе, используют хук useUser из context/user-context.ts для доступа к этой информации.
12. При выходе пользователя из системы (нажатие на кнопку "Выйти" в профиле пользователя) вызывается функция signOut из service/auth.ts, которая удаляет JWT токен из localStorage и перенаправляет пользователя на страницу входа.
Таким образом, авторизация пользователя в проекте реализована с использованием JWT токенов и защищенных маршрутов на клиентской стороне с помощью компонента AuthGuard. Информация о текущем пользователе хранится в контексте UserContext и доступна через хук

Вот еще несколько деталей об авторизации пользователя в проекте:
1. При отправке формы входа, пароль пользователя хешируется с помощью bcrypt перед отправкой на сервер. Это обеспечивает безопасность и предотвращает передачу пароля в открытом виде.
2. Если пользователь выбирает авторизацию через GitHub или Google, происходит перенаправление на соответствующий сервис авторизации. После успешной авторизации, сервис возвращает токен, который затем используется для получения информации о пользователе и создания JWT токена.
3. JWT токен содержит информацию о пользователе (ID, email и т.д.) и подписывается секретным ключом на сервере. При каждом запросе к API, требующем авторизации, JWT токен проверяется на сервере для подтверждения его подлинности.
4. Срок действия JWT токена ограничен (обычно несколько часов или дней). После истечения срока действия, пользователю необходимо снова пройти процесс авторизации.
5. На клиентской стороне JWT токен сохраняется в localStorage, что позволяет сохранять сессию пользователя даже после перезагрузки страницы. Однако, хранение JWT в localStorage потенциально уязвимо для XSS атак, поэтому важно обеспечить надлежащую санитизацию пользовательского ввода.
6. При каждом запросе к API JWT токен добавляется в заголовок Authorization. Это позволяет серверу идентифицировать пользователя и проверять его права доступа.
7. Если JWT токен отсутствует или недействителен, сервер возвращает ошибку 401 Unauthorized. На клиентской стороне это обрабатывается в AuthGuard, который перенаправляет пользователя на страницу входа.
Это основные моменты, касающиеся авторизации пользователя в проекте. Конечно, могут быть и другие нюансы в зависимости от конкретной реализации и требований безопасности проекта.